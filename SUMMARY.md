# This is the chapter organization of the book.

* [Preface](review/preface/preface.md)
* [ACKNOWLEDGMENTS](review/acknowledgments/acknowledgments.md)
* [ABOUT THIS BOOK](review/about_this_book/about this book.md)
* [ABOUT THE TITLE](review/about_the_title/about the title.md)
* [ABOUT THE COVER ILLUSTRATION](review/about_the_cover_illustration/about the cover illustration.md)

* [Chapter 1. A Few Basics](review/chapter_1/A few basics.md)
    * [1.1 Reflection's value proposition](review/chapter_1/1-Reflection's value proposition.md)
    * [1.2 Enter George the programmer](review/chapter_1/2-Enter George the programmer.md)
        * [1.2.1 Choosing reflection](review/chapter_1/2.1-Choosing reflection.md)
        * [1.2.2 Programming a reflective solution](review/chapter_1/2.2-Programming a reflective solution.md)
    * [Section 3](review/chapter_1/3-Examining.running.programs.md)
    * [Section 4](review/chapter_1/4-Finding a method a runtime.md)
    * [Section 5](review/chapter_1/5-Representing types with class objects.md)
        * [Section 5.1](review/chapter_1/5.1-Representing primitive types.md)
        * [Section 5.2](review/chapter_1/5.2-Representing interfaces.md)
        * [Section 5.3](review/chapter_1/5.3-Representing array types.md)
    * [Section 6](review/chapter_1/6-Understanding method objects.md)
        * [Section 6.1](review/chapter_1/6.1-Using dynamic invocation.md)
        * [Section 6.2](review/chapter_1/6.2-Using primitives with dynamic invocation.md)
        * [Section 6.3](review/chapter_1/6.3-Avoiding invocation pitfalls.md)
    * [Section 7](review/chapter_1/7-Diagramming for reflection.md)
    * [Section 8](review/chapter_1/8-Navigating the inheritance hierarchy.md)
        * [Section 8.1](review/chapter_1/8.1-Introspecting the inheritance hierarchy.md)
        * [Section 8.2](review/chapter_1/8.2-Exposing some surprises.md)
        * [Section 8.3](review/chapter_1/8.3-Another reflective circularity.md)
    * [Section 9](review/chapter_1/9-Summary.md)

* [Chapter 2](review/chapter_2/Accessing fields reflectively.md)
    * [Section 1](review/chapter_2/1-Serializing objects.md)
        * [Section 1.1](review/chapter_2/1.1-Serializing to XML.md)
        * [Section 1.2](review/chapter_2/1.2-Choosing reflection.md)
        * [Section 1.3](review/chapter_2/1.3-Designing serialization with reflection.md)
    * [Section 2](review/chapter_2/2-Finding fields at runtime.md)
    * [Section 3](review/chapter_2/3-Understanding field objects.md)
    * [Section 4](review/chapter_2/4-Getting and setting fields values.md)
    * [Section 5](review/chapter_2/5-Examining modifiers.md)
        * [Section 5.1](review/chapter_2/5.1-Introducing Member.md)
        * [Section 5.2](review/chapter_2/5.2-Interface introspection pitfall.md)
        * [Section 5.3](review/chapter_2/5.3-Introspecting for instance variables.md)
    * [Section 6](review/chapter_2/6-Accessing nonpublic members.md)
    * [Section 7](review/chapter_2/7-Working with arrays.md)
    * [Section 8](review/chapter_2/8-Serialiaztion, putting it all together.md)
    * [Section 9](review/chapter_2/9-Using reflective serialization.md)
    * [Section 10](review/chapter_2/10-Summary.md)

* [Chapter 3](review/chapter_3/Dynamic loading and reflective construction.md)
    * [Section 1](review/chapter_3/1-George's deployment problem.md)
        * [Section 1.1](review/chapter_3/1.1-Designing with patterns.md)
        * [Section 1.2](review/chapter_3/1.2-Programming a reflective solution.md)
        * [Section 1.3](review/chapter_3/1.3-Enhancing the factory method with reflection.md)
        * [Section 1.4](review/chapter_3/1.4-Combining benefits of delegation and reflction.md)
    * [Section 2](review/chapter_3/2-Loading classes dynamiclly.md)
        * [Section 2.1](review/chapter_3/2.1-Basics of forName.md)
        * [Section 2.2](review/chapter_3/2.2-Getting array classes.md)
        * [Section 2.3](review/chapter_3/2.3-Primitives and forName.md)
    * [Section 3](review/chapter_3/3.1-Constructing objects reflectively.md)
        * [Section 3.1](review/chapter_3/3.1-Reflective construction basics.md)
        * [Section 3.2](review/chapter_3/3.2-Using constructor objects.md)
        * [Section 3.3](review/chapter_3/3.3-Constructing arrays reflectively.md)
    * [Section 4](review/chapter_3/4-Designing for dynamic loading.md)
        * [Section 4.1](review/chapter_3/4.1-Disadvantages of reflective construction with arguments.md)
        * [Section 4.2](review/chapter_3/4.2-Initializing through an interface.md)
    * [Section 5](review/chapter_3/5-Implementing deserialization.md)
        * [Section 5.1](review/chapter_3/5.1-Initiating deserialization.md)
        * [Section 5.2](review/chapter_3/5.2-Constructing the instances.md)
        * [Section 5.3](review/chapter_3/5.3-Restoring the object structure.md)
    * [Section 6](review/chapter_3/6-George's serialization, limitations.md)
        * [Section 6.1](review/chapter_3/6.1-No interaction with readObject or writeObject.md)
        * [Section 6.2](review/chapter_3/6.2-No handling of final instance variables.md)
        * [Section 6.3](review/chapter_3/6.3-Only no-argument constructors.md)
        * [Section 6.4](review/chapter_3/6.4-No handling of illegal XML characters.md)
        * [Section 6.5](review/chapter_3/6.5-Performance.md)
    * [Section 7](review/chapter_3/7-Summary.md)

* [Chapter 4](review/chapter_4/Using Java's dynamic proxy.md)
    * [Section 1](review/chapter_4/1-Working with proxies.md)
    * [Section 2](review/chapter_4/2-George's tracing problem.md)
    * [Section 3](review/chapter_4/3-Exploring Proxy.md)
        * [Seciton 3.1](review/chapter_4/3.1-Understanding invocation handlers.md)
        * [Seciton 3.2](review/chapter_4/3.2-Handling the methods of Object.md)
    * [Section 4](review/chapter_4/4-Implementing a tracing proxy.md)
    * [Section 5](review/chapter_4/5-A note on factories.md)
    * [Section 6](review/chapter_4/6-Chaining proxies.md)
        * [Seciton 6.1](review/chapter_4/6.1-Structuring invocation handlers for chaining.md)
        * [Seciton 6.2](review/chapter_4/6.2-Implementing a synchronized proxy.md)
        * [Seciton 6.3](review/chapter_4/6.3-Chaining the two proxies.md)
    * [Section 7](review/chapter_4/7-Stubbing interfaces for unit testing.md)
        * [Seciton 7.1](review/chapter_4/7.1-Examining stubs.md)
        * [Seciton 7.2](review/chapter_4/7.2-Design for stubbing with Proxy.md)
        * [Seciton 7.3](review/chapter_4/7.3-Implementation of stubbing with Proxy.md)
    * [Section 8](review/chapter_4/8-Generating SOAP remote proxies.md)
    * [Section 9](review/chapter_4/9-Pitfalls of using Proxy.md)
    * [Section 10](review/chapter_4/10-Summary.md)

* [Chapter 5](review/chapter_5/Call stack introspection.md)
    * [Section 1](review/chapter_5/5.1-George's logging problem.md)
    * [Section 2](review/chapter_5/5.2-Performing call stack introspection.md)
